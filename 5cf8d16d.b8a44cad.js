(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{123:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return b})),a.d(t,"default",(function(){return s}));var n=a(2),r=a(6),l=(a(0),a(218)),o={title:"Re-examining our approach to memory mapping",author:"David G. Simmons",author_title:"QuestDB Team",author_url:"https://github.com/davidgs",author_image_url:"https://avatars.githubusercontent.com/davidgs",description:"What we learned by re-examining our approach to memory mapping. A low level implementation, as close as posibble to the kernel, enabled even greater performance.",tags:["performance","deep-dive"],image:"/img/blog/2020-08-19/banner.png"},i={permalink:"/blog/2020/08/19/memory-mapping-deep-dive",source:"@site/blog/2020-08-19-memory-mapping-deep-dive.md",description:"What we learned by re-examining our approach to memory mapping. A low level implementation, as close as posibble to the kernel, enabled even greater performance.",date:"2020-08-19T00:00:00.000Z",tags:[{label:"performance",permalink:"/blog/tags/performance"},{label:"deep-dive",permalink:"/blog/tags/deep-dive"}],title:"Re-examining our approach to memory mapping",readingTime:10.075,truncated:!0,prevItem:{title:"Light-weight, blazing fast stack for your IoT application",permalink:"/blog/2020/08/25/questitto"},nextItem:{title:"My journey making QuestDB",permalink:"/blog/2020/08/06/my-journey-writing-questdb"}},b=[{value:"How the performance improvements started",id:"how-the-performance-improvements-started",children:[]},{value:"Storage performance",id:"storage-performance",children:[]},{value:"Pages of data",id:"pages-of-data",children:[]},{value:"One page to rule them all",id:"one-page-to-rule-them-all",children:[]},{value:"Kernels are smart",id:"kernels-are-smart",children:[]},{value:"Speed",id:"speed",children:[]},{value:"Conclusions",id:"conclusions",children:[{value:"32-bit Read",id:"32-bit-read",children:[]},{value:"32-Bit Write",id:"32-bit-write",children:[]},{value:"64-bit Read",id:"64-bit-read",children:[]},{value:"64-bit Write",id:"64-bit-write",children:[]},{value:"String Read",id:"string-read",children:[]}]}],c={rightToc:b};function s(e){var t=e.components,o=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},c,o,{components:t,mdxType:"MDXLayout"}),Object(l.b)("div",{className:"banner",style:{fontSize:"14px",marginBottom:"1rem",textAlign:"center"}},Object(l.b)("img",{alt:"Hand holding an analog stopwatch",src:"/img/blog/2020-08-19/banner.png"}),Object(l.b)("div",null,"Photo by ",Object(l.b)("a",{href:"https://unsplash.com/@veri_ivanova?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"},"Veri Ivanova")," on ",Object(l.b)("a",{href:"https://unsplash.com/s/photos/speed?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"},"Unsplash"))),Object(l.b)("p",null,"How does QuestDB get the kind of performance it does, and how are we continuing\nto squeeze another 50-60% out of it? We are constantly learning more about the\nfundamental concepts of memory performance, and this is one example of how what\nwe at first thought would be ",Object(l.b)("em",{parentName:"p"},"worse")," for performance ended up bringing us a\nrather substantial boost in overall memory performance."),Object(l.b)("p",null,"We will walk you through how some of our initial thoughts on storage and\nmemory-mapping evolved to bring us better performance overall."),Object(l.b)("p",null,"If you like QuestDB, please do give us a star on\n",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/questdb/questdb"}),"GitHub")),Object(l.b)("h2",{id:"how-the-performance-improvements-started"},"How the performance improvements started"),Object(l.b)("p",null,"QuestDB started out with a single-threaded approach to queries and such. But one\nobvious way to improve performance in a Java application like this is to\nparallelize as much as you can by using multiple threads of execution."),Object(l.b)("p",null,"I've written multi-threaded applications, and they are not easy to do. It's hard\nto coordinate the work between multiple threads, and to make sure that there are\nno race conditions, collisions, etc."),Object(l.b)("h2",{id:"storage-performance"},"Storage performance"),Object(l.b)("p",null,"So first it's important to understand that QuestDB stores it's data in columnar\nformat. We store each column of data in a file. So for every column of data,\nthere is a file."),Object(l.b)("p",null,"We then split those columns up into data frames that are independent and can be\ncomputed completely independently of each other."),Object(l.b)("p",null,"The problem we encountered with this framing scheme was that it was impossible\nto frame variable length data. Data spilled out of the frame, making it\ndifficult to manage."),Object(l.b)("p",null,"You see, we store fixed length fields with fixed length values, such that\naligning frames to 8 bytes would ensure that all our fixed length data does not\nstraddle frames. Hence all the columns are the same frame width. But strings and\nblobs can't be forced into 8 bytes without making them useless."),Object(l.b)("p",null,"So we could extract extreme performance out of all the fixed-length values, but\nthese variable-length values dragged the performance back down."),Object(l.b)("p",null,"Which brings us to pages and how data is referenced in memory."),Object(l.b)("h2",{id:"pages-of-data"},"Pages of data"),Object(l.b)("p",null,"QuestDB uses memory-mapped pages to reference data in order to make it really\nfast. If you're dividing up your data into pages, and all data has a fixed\nlength, then it's relatively easy to ensure that you don't have data that spans\nmultiple pages. You just break pages at multiples of 8-bytes and everything will\nfit within page boundaries."),Object(l.b)("p",null,"When you add variable-length data, suddenly you cannot ensure that everything\nwill line up along page boundaries and you will have the very real possibility\n-- actually a certainty -- that you may have to jump from one page to another\njust to get all the data contained in a frame."),Object(l.b)("p",null,"This, it turns out, is hugely inefficient. If (data is in frame) then (process\nthat data) else (figure out where the rest of the data is, get that, then\nprocess it all). This kind of if-then-else sprinkled throughout the code is a)\nhard to debug and b) leads to lots of branching, which slows down execution."),Object(l.b)("p",null,"In order to prevent variable length data from straddling frames we would need to\nhave different frame lengths per column. Furthermore, calculating aligned frame\nlengths for variable length data is non trivial and requires scanning the entire\ndata set which would reversing any performance gains from parallelization."),Object(l.b)("h2",{id:"one-page-to-rule-them-all"},"One page to rule them all"),Object(l.b)("p",null,"(Yes, I just made a ",Object(l.b)("em",{parentName:"p"},"The Highlander"),"\n",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Highlander_(film)"}),"reference"),")"),Object(l.b)("p",null,"What if, in order to get around data being on multiple pages, we simply used\n",Object(l.b)("em",{parentName:"p"},"one"),' page for all of the data? Of course my first question was "Don\'t you at\nsome point reach a limit on the page size?" but Vlad and Patrick assured me\nthere is, indeed, no limit on a page size.'),Object(l.b)("p",null,'If your page size is bigger than the available memory, the kernel will handle\nswapping pages in and out for you as you try to access different parts of the\npage. So of course I asked "well then, why didn\'t you do this from the\nbeginning?"'),Object(l.b)("p",null,'Vlad, in his typically self-deprecating style, just said "We didn\'t know. We\nthought we should keep them to a certain size to keep them from growing out of\ncontrol" which, quite frankly, seems like the right answer.'),Object(l.b)("p",null,"We'd just resize those smaller pages as needed. But as Vlad explained, if you do\nthat then you need to copy the data over to the new, resized page and \"copying\ncan take over your life.\" Databases aren't built to maximize the efficiency of\ndata copying. They are built to maximize the ability to extract value from data.\nCopying data from one page to another isn't extracting value."),Object(l.b)("p",null,"So they tried just allocating a new page, and jumping from one page to the next\nas needed to find the required data. This cut down on the copying of data, but\nit lead to the problems outlined in the previous section. You never knew which\npage your data was going to be on, and jumping from one page to another was\nhugely inefficient."),Object(l.b)("p",null,'So they tried having just the one page. One massive page (that you can grow as\nneeded, without copying data around). Vlad, again in his style, said the\nperformance turned out to be "not bad" with this approach. And by "not bad" he\nof course meant about a 60% performance improvement.'),Object(l.b)("p",null,"When you get into using one single page, of course the total available address\nspace comes into play. But since QuestDB only runs on 64-bit architectures, we\nhave 2^64 address space, which is more than enough."),Object(l.b)("p",null,"This is where Patrick jumped in to explain that when you have an area of memory\nmapped from a file, when the file grows you remap the new size into memory. The\noperating system does not need to copy anything; the virtual memory model allows\nthe OS to just remap the already mapped pages into the newly mapped memory\nregion. In many cases, the OS may have already reserved the entire address space\nfor you so your new mapping is in the same region as the old, just bigger."),Object(l.b)("h2",{id:"kernels-are-smart"},"Kernels are smart"),Object(l.b)("p",null,"The kernel allocated a full sized address space for your file when you requested\nthe memory-mapped file. And apparently this is true across Linux, macOS and\nWindows. So from that point on, there's really no further copying that needs to\nhappen."),Object(l.b)("p",null,"Furthermore, the kernel is going to handle paging parts of that file in and out\nof memory as needed. Now, I'm old-school Unix, and page-swapping which lead to\nthrashing was always something we worried about back in the olden days. So I\nasked about it. According to Patrick, this could only happen really if you have\na massive file that you are reading basically randomly at high speed. Other than\nthat, the kernel will handle reading ahead and pre-loading pages as needed in\norder to be as efficient as possible."),Object(l.b)("p",null,"Kernels, it turns out, are smart. In fact, kernels are basically smarter than\nyou or I will ever hope to be. They've been developed across decades to be\nhugely efficient at doing these things. It's what they do. The kernel will\nmemory map the file into the file cache and even if it needs to move stuff\naround, it can move the logical address and it's still the same underlying\nphysical memory pages."),Object(l.b)("p",null,"If you think that you can take over caching the data from the OS and do a better\njob of managing the memory space, and the allocation and re-allocation of the\nmemory, you're wrong. Again, this is what the Kernel does, and at some level,\neven if you try to take this job away from the kernel, it is ",Object(l.b)("em",{parentName:"p"},"still")," doing some\namount of it anyway. So your attempts to take this memory management and\nallocation away from the kernel has done little more than just add another layer\non top of what the kernel is doing anyway. Another layer on top of something is\nbasically never more efficient than the original thing."),Object(l.b)("p",null,"When you read an offset into a file, you send a buffer to read into, the address\nto start reading at, and the offset into the file. Now, the kernel is going to\ncache all of that for you as you do it, because that's the kernel's job, really.\nBut many database developers then take that, and cache it themselves, with their\nown caching scheme."),Object(l.b)("h2",{id:"speed"},"Speed"),Object(l.b)("p",null,"When I asked Vlad about this, and how it relates to query speed, he was quite\nexplicit in saying that thinking you (a database developer) can beat the kernel\nis pure folly. Postgres tries this and, according to Vlad, an aggregation over a\nlarge (really large!) dataset can take 5 ",Object(l.b)("em",{parentName:"p"},"minutes"),", whereas the same aggregation\non QuestDB takes only 60ms. Those aren't typos."),Object(l.b)("p",null,"To both Patrick and Vlad (and me, for what that's worth), the idea that we, as\ndevelopers, can be better at these operations than the kernel (when really we're\ndoing them ",Object(l.b)("em",{parentName:"p"},"on top of")," the kernel anyway) is simply ridiculous. If I take an\narmy of researchers and spend a decade of development, then ",Object(l.b)("em",{parentName:"p"},"maybe")," I can do it\nbetter than the kernel, but during that time guess what? The army of people\nworking on the kernel will have found further improvements and left me behind\nanyway."),Object(l.b)("p",null,"It comes down to letting the kernel do its job, and us doing ours. And our job\nis to exploit the kernel for every ounce of performance we can get out of it\nwithout trying to do it's job for it."),Object(l.b)("h2",{id:"conclusions"},"Conclusions"),Object(l.b)("p",null,"When it comes to performance claims, we always try to back them up with actual\nnumbers that can be replicated. You can run these tests yourself, and you can\nalways go and look at the\n",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/questdb/questdb/tree/master/benchmarks/src/main/java/org/questdb"}),"source code"),"\nfor these tests to see how they are implemented."),Object(l.b)("p",null,"We think these numbers speak for themselves."),Object(l.b)("p",null,"These first results are for the primitives and represent 10,000 reads/writes:"),Object(l.b)("h3",{id:"32-bit-read"},"32-bit Read"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Benchmark"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Mode"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cnt"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Score"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryReadBenchmark.testIntContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4601.940"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryReadBenchmark.testIntLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"7064.822"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")))),Object(l.b)("h3",{id:"32-bit-write"},"32-Bit Write"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Benchmark"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Mode"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cnt"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Score"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryBenchmark.testPutIntContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5270.264"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryBenchmark.testPutIntLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5692.148"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")))),Object(l.b)("h3",{id:"64-bit-read"},"64-bit Read"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Benchmark"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Mode"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cnt"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Score"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryLongReadBenchmark.testLongContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4088.338"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryLongReadBenchmark.testLongLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5022.875"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")))),Object(l.b)("h3",{id:"64-bit-write"},"64-bit Write"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Benchmark"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Mode"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cnt"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Score"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryLongWriteBenchmark.testPutLongContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4413.181"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryLongWriteBenchmark.testPutLongLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"6976.593"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")))),Object(l.b)("p",null,"And here are the results for strings, which represent 100 reads/writes:"),Object(l.b)("h3",{id:"string-read"},"String Read"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Benchmark"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Mode"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Cnt"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Score"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryStrReadBenchmark.testGetStrContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"300.346"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryStrReadBenchmark.testGetStrLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"525.775"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryStrWriteBenchmark.testPutStrContiguous"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2.019"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VirtualMemoryStrWriteBenchmark.testPutStrLegacy"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"avgt"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"5"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3.646"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ns/op")))),Object(l.b)("p",null,"For those of you that are more graphicly-inclined:"),Object(l.b)("p",null,Object(l.b)("img",{alt:"Benchmark showing the relative performance of primitive types",src:a(329).default})),Object(l.b)("p",null,Object(l.b)("img",{alt:"Benchmark showing the relative performance of string types",src:a(330).default})),Object(l.b)("p",null,"Again, we think these numbers speak for themselves, but we're always happy to\nhear from you, our users and community, about what you think."))}s.isMDXComponent=!0},329:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/primitives-20aae46c1b4abd47c5142c524ebbc624.png"},330:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/strings-c15a13ab0f60a61ddfcc943ad4050780.png"}}]);