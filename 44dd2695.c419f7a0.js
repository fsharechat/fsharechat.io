(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{110:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(2),s=n(6),i=(n(0),n(218)),o={title:"SQL extensions",description:"QuestDB attempts to implement standard ANSI SQL and extends it for time series needs. This document covers such extensions."},r={unversionedId:"concept/sql-extensions",id:"concept/sql-extensions",isDocsHomePage:!1,title:"SQL extensions",description:"QuestDB attempts to implement standard ANSI SQL and extends it for time series needs. This document covers such extensions.",source:"@site/docs/concept/sql-extensions.md",slug:"/concept/sql-extensions",permalink:"/docs/concept/sql-extensions",version:"current",sidebar:"docs",previous:{title:"Designated timestamp",permalink:"/docs/concept/designated-timestamp"},next:{title:"Partitions",permalink:"/docs/concept/partitions"}},c=[{value:"SQL extensions",id:"sql-extensions",children:[{value:"LATEST BY",id:"latest-by",children:[]},{value:"SAMPLE BY",id:"sample-by",children:[]},{value:"Timestamp search",id:"timestamp-search",children:[]}]},{value:"Differences from standard SQL",id:"differences-from-standard-sql",children:[{value:"Optionality of SELECT * FROM",id:"optionality-of-select--from",children:[]},{value:"Optionality of GROUP BY",id:"optionality-of-group-by",children:[]},{value:"Implicit HAVING",id:"implicit-having",children:[]}]}],l={rightToc:c};function b(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"QuestDB attempts to implement standard ANSI SQL. We also attempt to be\nPostgreSQL compatible, although some of it is work in progress. This page\npresents the main extensions we bring to SQL and the main differences that one\nmight find in SQL but not in QuestDB's dialect."),Object(i.b)("h2",{id:"sql-extensions"},"SQL extensions"),Object(i.b)("p",null,"We have extended SQL language to support our data storage model and simplify\nsemantics of time series queries."),Object(i.b)("h3",{id:"latest-by"},"LATEST BY"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/guide/crud/"}),"LATEST BY")," is a clause introduced to help perform UPDATE and\nDELETE operations within an append-only framework."),Object(i.b)("h3",{id:"sample-by"},"SAMPLE BY"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/sql/select/#sample-by"}),"SAMPLE BY")," for time based\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/function/aggregation/"}),"aggregations")," with an efficient syntax.\nThe short query below will return the simple average balance from a list of\naccounts by one month buckets."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-questdb-sql",metastring:'title="Using SAMPLE BY"',title:'"Using',SAMPLE:!0,'BY"':!0}),"select avg(balance) from accounts sample by 1M\n")),Object(i.b)("h3",{id:"timestamp-search"},"Timestamp search"),Object(i.b)("p",null,"Timestamp search can be performed with regular operators, e.g ",Object(i.b)("inlineCode",{parentName:"p"},">"),", ",Object(i.b)("inlineCode",{parentName:"p"},"<=")," etc.\nHowever, QuestDB provides a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/reference/sql/where/#timestamp-and-date"}),"native notation")," which is faster\nand less verbose."),Object(i.b)("h2",{id:"differences-from-standard-sql"},"Differences from standard SQL"),Object(i.b)("h3",{id:"optionality-of-select--from"},"Optionality of SELECT ","*"," FROM"),Object(i.b)("p",null,"In QuestDB ",Object(i.b)("inlineCode",{parentName:"p"},"select * from")," is optional. So ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT * FROM tab;")," achieves the\nsame effect as ",Object(i.b)("inlineCode",{parentName:"p"},"tab;")," While ",Object(i.b)("inlineCode",{parentName:"p"},"select * from")," makes SQL look more complete, there\nare examples where its optionality makes things a lot easier to read."),Object(i.b)("h3",{id:"optionality-of-group-by"},"Optionality of GROUP BY"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"GROUP BY")," clause is optional and can be ommitted as the QuestDB optimiser\nderives group-by implementation from ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," clause."),Object(i.b)("p",null,"In standard SQL, users might write a query like the below."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-questdb-sql"}),"SELECT a, b, c, d, sum(e) FROM tab GROUP BY a, b, c, d;\n")),Object(i.b)("p",null,"However, enumerating subset of ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," columns in the ",Object(i.b)("inlineCode",{parentName:"p"},"GROUP BY")," clause\nredundant and therefore unnecessary. The same SQL in QuestDB SQL-dialect can be\nwritten as:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-questdb-sql"}),"SELECT a, b, c, d, sum(e) FROM tab;\n")),Object(i.b)("h3",{id:"implicit-having"},"Implicit HAVING"),Object(i.b)("p",null,"Let's look at another more complex example using HAVING in standard SQL."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-questdb-sql"}),"SELECT a, b, c, d, sum(e)\nFROM tab\nGROUP BY a, b, c, d\nHAVING sum(e) > 100;\n")),Object(i.b)("p",null,"In QuestDB's dialect, ",Object(i.b)("inlineCode",{parentName:"p"},"select * from")," optionality and featherweight sub-queries\ncome to the rescue to create a smaller, more readable query, without unnecessary\nrepetitive aggregations. ",Object(i.b)("inlineCode",{parentName:"p"},"HAVING")," functionality can be obtained implicitly as\nfollows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-questdb-sql"}),"(SELECT a, b, c, d, sum(e) s FROM tab) WHERE s > 100;\n")))}b.isMDXComponent=!0}}]);